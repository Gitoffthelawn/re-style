(function(global) { 'use strict'; define(async ({ // This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
	'node_modules/web-ext-utils/browser/': { manifest, },
	'node_modules/web-ext-utils/loader/native': connect,
	'node_modules/web-ext-utils/utils/': { reportError, reportSuccess, },
	'node_modules/es6lib/functional': { debounce, },
	'fetch!./native.js': script,
	'common/options': options,
	'../util': { debounceIdle, },
	require,
}) => {
let active = options.chrome.value; options.chrome.onChange(([ value, ]) => { active = value; writeStyles(!value); });

const styles = new Set; let native = null;
const minify = false;

class ChromeStyle {
	constructor(path, chrome, content) {
		styles.add(this);
		this.path = path;
		// the sheets are loaded with origin 'user', which means their priority is below 'author' sheets unless they are !important, seee: https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade#Cascading_order
		// that means they are pretty useless unless they are !important ==> add that to all rules
		this.chrome  = (chrome  || '').toString({ minify, important: true, namespace: false, });
		this.content = (content || '').toString({ minify, important: true, namespace: false, });
		writeStyles();
	}

	destroy() {
		if (!styles.has(this)) { return; }
		styles.delete(this);
		this.code = null;
		writeStyles();
	}

	toJSON() { return this; }

	static fromJSON({ path, chrome, content, }) {
		// writeStyles(); // this is only used to load styles after a restart. This style should not have changed since it was last written.
		return new ChromeStyle(path, chrome, content);
	}
}

const writeStyles = debounceIdle(async (clear) => { try {
	if (!active && !clear) { return; }
	native = native || (await connect({ script, sourceURL: require.toUrl('./native.js'), }));
	const sorted = clear ? null : Array.from(styles).sort((a, b) => a.path < b.path ? -1 : 1);

	// TODO: this throws all @namespace declarations into a single file. Is that even supposed to work? Do later (default) declarations overwrite earlier ones?
	// TODO: do @import rules work? Should they?

	const files = { chrome: '', content: '', };
	clear || Object.keys(files).forEach(type => (files[type] =
		`/* Do not edit this file. It is managed by the ${manifest.name} extension. */\n` /*  v${manifest.version} */
		+ sorted.filter(_=>_[type]).map(
			style => `/* ${ style.path } */${ minify ? '' : '\n' }${ style[type] }`
		).join(
			(minify ? '' : '\n') +`/*"*//*'*/;};};};};};}@media not all {}\n`
			// this terminator sequence closes open strings, comments, blocks and declarations
			// the media query seems to "reset" the parser (and doesn't do anything itself)
		) +'\n'
	));

	const changed = (await native.request('writeUserChromeCss', options.chrome.children.profile.value, clear ? null : files));

	changed && reportSuccess(`The UI styles were changed`, `restart the browser to apply the changes`);
} catch (error) {
	reportError(`Failed to write chrome styles`, error);
} finally { destroy(); } }, 1e3);

const destroy = debounce(() => {
	native && native.destroy();
	native = null;
}, 60e3);

return ChromeStyle;

}); })(this);
