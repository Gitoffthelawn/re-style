(function(global) { 'use strict'; define(async ({ // This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
	'node_modules/web-ext-utils/browser/': { manifest, },
	'node_modules/web-ext-utils/loader/native': connect,
	'node_modules/web-ext-utils/utils/': { reportError, reportSuccess, },
	'node_modules/es6lib/functional': { debounce, },
	'node_modules/regexpx/': RegExpX,
	'fetch!./native.js': script,
	'common/options': options,
	'../parser': { tokenize, },
	'../lib/css': CSS,
	require,
}) => {
let active = options.chrome.value; options.chrome.onChange(([ value, ]) => { active = value; writeStyles(!value); });

const styles = new Set; let native = null;
const uglify = false;

class ChromeStyle {
	constructor(path, code) {
		styles.add(this);
		this.path = path;
		// the sheets are loaded with origin 'user', which means their priority is below 'author' sheets unless they are !important, seee: https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade#Cascading_order
		// that means they are pretty useless unless they are !important ==> add that to all rules
		this.code = mutate(code, {
			init: ast => (this.ast = ast),
			rule: node => {
				node.declarations.forEach(decl => decl.type === 'declaration'
					&& (decl.value = decl.value.replace(/\s*!important$|$/, ' !important'))
				);
			},
			document: node => {
				// console.log('document', node);
				const include = tokenize(node.document).filter(_=>!(/^\s*$|^,$|^\/\*/).test(_))
				.filter(exp => rChromeUrl.test(exp)/* || console.log('skip document', exp)*/);
				if (!include.length) {
					// console.log('remove block', node.document);
					node.type = 'comment'; node.comment = 'removed block'; delete node.rules; delete node.vendor;
				} else {
					node.document = include.join(', ');
				}
			},
			source: path,
		});
		writeStyles();
	}

	destroy() {
		if (this.code == null) { return; }
		styles.delete(this);
		this.code = null;
		writeStyles();
	}

	toJSON() {
		return { type: 'ChromeStyle', path: this.path, code: this.code, };
	}

	static fromJSON({ path, code, }) {
		const _this = Object.create(ChromeStyle.prototype);
		styles.add(_this);
		_this.path = path; _this.code = code;
		// writeStyles(); // this is only used to load styles after a restart. This style should not have changed since it was last written.
		return _this;
	}
}

const writeStyles = debounceIdle(async (clear) => { try {
	if (!active && !clear) { return; }
	native = native || (await connect({ script, sourceURL: require.toUrl('./native.js'), }));
	// TODO: this throws all @namespace declarations into a single file. Is that even supposed to work? Do later (default) declarations overwrite earlier ones?
	// TODO: do @import rules work? Should they?
	const code = clear || `/* Do not edit this file. It is managed by the ${manifest.name} extension. */\n` /*  v${manifest.version} */
	// +`/* Last change: ${new Date(Date.now() - new Date().getTimezoneOffset() * 60e3).toISOString().replace('T', ' ').slice(0, -1)} */\n` // this would force a change
	+ Array.from(styles).sort((a, b) => a.path < b.path ? -1 : 1)
	.map(({ path, code, }) => `/* ${ path } */${ uglify ? '' : '\n' }${ code }`)
	.join((uglify ? '' : '\n') +`/*"*//*'*/;};};};};};}@media not all {}\n`) +'\n';
	// this terminator sequence closes open strings, comments, blocks and declarations
	// the media query seems to "reset" the parser (and doesn't do anything itself)
	const changed = (await native.request('writeUserChromeCss', options.chrome.children.profile.value, clear ? '' : code));
	changed && reportSuccess(`The UI styles were changed`, `restart the browser to apply the changes`);
} catch (error) {
	reportError(`Failed to write chrome styles`, error);
} finally { destroy(); } }, 1e3);

const destroy = debounce(() => {
	native && native.destroy();
	native = null;
}, 60e3);

function mutate(code, { init, rule, document, finish, source, }) {
	let ast = CSS.parse(code, {
		source, silent: false, // ...
	}).stylesheet;
	const arg = init && init(ast);
	rule && (function walk(node) {
		switch (node.type) {
			case 'rule': rule && rule(node, arg); break;
			case 'document': document && document(node, arg); break;
		}
		node.rules && node.rules.forEach(walk);
	})(ast);
	finish && (ast = finish(ast));
	return CSS.stringify({ stylesheet: ast, }, {
		indent: uglify ? false : '\t', compress: uglify,
		sourcemap: false, inputSourcemaps: false,
	});
}

const rChromeUrl = RegExpX`
	^url (?:-prefix)? \( ["']? (
		  about: # any about page // TODO: exclude blank?
		| data: # probably also blob: ?
		| view-source:
		| (?:chrome|resource|moz-extension)://
		| https://addons.mozilla.org/
	)
|
	^domain\( ["']? (
		addons.mozilla.org
	) ["']? \)$
|
	^regexp\( ["']? .* ( # this is quite liberal
		  about \\? : # any about page // TODO: exclude blank?
		| data \\? : # probably also blob: ?
		| view-source \\? :
		| (?:chrome|resource|moz-extension) \\? :
		| addons\\\\?.mozilla\\\\?.org
	) .* ["']? \)$
`;

return ChromeStyle;

/* global setTimeout, requestIdleCallback, */
function debounceIdle(callback, minDelay) {
	let time = 0, args = null;
	function loop(idle) {
		const left = idle.timeRemaining(); time -= left;
		if (time <= 0) { const tmp = args; args = null; callback.apply(null, tmp); }
		else { setTimeout(() => requestIdleCallback(loop), left + 1); }
	}
	return function(..._args) {
		!args && requestIdleCallback(loop);
		time = minDelay; args = _args;
	};
}

}); })(this);
